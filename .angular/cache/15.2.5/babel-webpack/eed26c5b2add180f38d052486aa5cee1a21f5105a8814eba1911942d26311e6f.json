{"ast":null,"code":"import { HttpResponse, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { of, throwError } from 'rxjs';\nimport { delay, materialize, dematerialize } from 'rxjs/operators';\nimport { Role } from '@app/_models';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@app/_services\";\n// array in local storage for accounts\nconst accountsKey = 'angular-15-signup-verification-boilerplate-accounts';\nlet accounts = JSON.parse(localStorage.getItem(accountsKey)) || [];\nexport class FakeBackendInterceptor {\n  constructor(alertService) {\n    this.alertService = alertService;\n  }\n  intercept(request, next) {\n    const {\n      url,\n      method,\n      headers,\n      body\n    } = request;\n    const alertService = this.alertService;\n    return handleRoute();\n    function handleRoute() {\n      switch (true) {\n        case url.endsWith('/accounts/authenticate') && method === 'POST':\n          return authenticate();\n        case url.endsWith('/accounts/refresh-token') && method === 'POST':\n          return refreshToken();\n        case url.endsWith('/accounts/revoke-token') && method === 'POST':\n          return revokeToken();\n        case url.endsWith('/accounts/register') && method === 'POST':\n          return register();\n        case url.endsWith('/accounts/verify-email') && method === 'POST':\n          return verifyEmail();\n        case url.endsWith('/accounts/forgot-password') && method === 'POST':\n          return forgotPassword();\n        case url.endsWith('/accounts/validate-reset-token') && method === 'POST':\n          return validateResetToken();\n        case url.endsWith('/accounts/reset-password') && method === 'POST':\n          return resetPassword();\n        case url.endsWith('/accounts') && method === 'GET':\n          return getAccounts();\n        case url.match(/\\/accounts\\/\\d+$/) && method === 'GET':\n          return getAccountById();\n        case url.endsWith('/accounts') && method === 'POST':\n          return createAccount();\n        case url.match(/\\/accounts\\/\\d+$/) && method === 'PUT':\n          return updateAccount();\n        case url.match(/\\/accounts\\/\\d+$/) && method === 'DELETE':\n          return deleteAccount();\n        default:\n          // pass through any requests not handled above\n          return next.handle(request);\n      }\n    }\n    // route functions\n    function authenticate() {\n      const {\n        email,\n        password\n      } = body;\n      const account = accounts.find(x => x.email === email && x.password === password && x.isVerified);\n      if (!account) return error('Email or password is incorrect');\n      // add refresh token to account\n      account.refreshTokens.push(generateRefreshToken());\n      localStorage.setItem(accountsKey, JSON.stringify(accounts));\n      return ok({\n        ...basicDetails(account),\n        jwtToken: generateJwtToken(account)\n      });\n    }\n    function refreshToken() {\n      const refreshToken = getRefreshToken();\n      if (!refreshToken) return unauthorized();\n      const account = accounts.find(x => x.refreshTokens.includes(refreshToken));\n      if (!account) return unauthorized();\n      // replace old refresh token with a new one and save\n      account.refreshTokens = account.refreshTokens.filter(x => x !== refreshToken);\n      account.refreshTokens.push(generateRefreshToken());\n      localStorage.setItem(accountsKey, JSON.stringify(accounts));\n      return ok({\n        ...basicDetails(account),\n        jwtToken: generateJwtToken(account)\n      });\n    }\n    function revokeToken() {\n      if (!isAuthenticated()) return unauthorized();\n      const refreshToken = getRefreshToken();\n      const account = accounts.find(x => x.refreshTokens.includes(refreshToken));\n      // revoke token and save\n      account.refreshTokens = account.refreshTokens.filter(x => x !== refreshToken);\n      localStorage.setItem(accountsKey, JSON.stringify(accounts));\n      return ok();\n    }\n    function register() {\n      const account = body;\n      if (accounts.find(x => x.email === account.email)) {\n        // display email already registered \"email\" in alert\n        setTimeout(() => {\n          alertService.info(`\n                        <h4>Email Already Registered</h4>\n                        <p>Your email ${account.email} is already registered.</p>\n                        <p>If you don't know your password please visit the <a href=\"${location.origin}/account/forgot-password\">forgot password</a> page.</p>\n                        <div><strong>NOTE:</strong> The fake backend displayed this \"email\" so you can test without an api. A real backend would send a real email.</div>\n                    `, {\n            autoClose: false\n          });\n        }, 1000);\n        // always return ok() response to prevent email enumeration\n        return ok();\n      }\n      // assign account id and a few other properties then save\n      account.id = newAccountId();\n      if (account.id === 1) {\n        // first registered account is an admin\n        account.role = Role.Admin;\n      } else {\n        account.role = Role.User;\n      }\n      account.dateCreated = new Date().toISOString();\n      account.verificationToken = new Date().getTime().toString();\n      account.isVerified = false;\n      account.refreshTokens = [];\n      delete account.confirmPassword;\n      accounts.push(account);\n      localStorage.setItem(accountsKey, JSON.stringify(accounts));\n      // display verification email in alert\n      setTimeout(() => {\n        const verifyUrl = `${location.origin}/account/verify-email?token=${account.verificationToken}`;\n        alertService.info(`\n                    <h4>Verification Email</h4>\n                    <p>Thanks for registering!</p>\n                    <p>Please click the below link to verify your email address:</p>\n                    <p><a href=\"${verifyUrl}\">${verifyUrl}</a></p>\n                    <div><strong>NOTE:</strong> The fake backend displayed this \"email\" so you can test without an api. A real backend would send a real email.</div>\n                `, {\n          autoClose: false\n        });\n      }, 1000);\n      return ok();\n    }\n    function verifyEmail() {\n      const {\n        token\n      } = body;\n      const account = accounts.find(x => !!x.verificationToken && x.verificationToken === token);\n      if (!account) return error('Verification failed');\n      // set is verified flag to true if token is valid\n      account.isVerified = true;\n      localStorage.setItem(accountsKey, JSON.stringify(accounts));\n      return ok();\n    }\n    function forgotPassword() {\n      const {\n        email\n      } = body;\n      const account = accounts.find(x => x.email === email);\n      // always return ok() response to prevent email enumeration\n      if (!account) return ok();\n      // create reset token that expires after 24 hours\n      account.resetToken = new Date().getTime().toString();\n      account.resetTokenExpires = new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString();\n      localStorage.setItem(accountsKey, JSON.stringify(accounts));\n      // display password reset email in alert\n      setTimeout(() => {\n        const resetUrl = `${location.origin}/account/reset-password?token=${account.resetToken}`;\n        alertService.info(`\n                    <h4>Reset Password Email</h4>\n                    <p>Please click the below link to reset your password, the link will be valid for 1 day:</p>\n                    <p><a href=\"${resetUrl}\">${resetUrl}</a></p>\n                    <div><strong>NOTE:</strong> The fake backend displayed this \"email\" so you can test without an api. A real backend would send a real email.</div>\n                `, {\n          autoClose: false\n        });\n      }, 1000);\n      return ok();\n    }\n    function validateResetToken() {\n      const {\n        token\n      } = body;\n      const account = accounts.find(x => !!x.resetToken && x.resetToken === token && new Date() < new Date(x.resetTokenExpires));\n      if (!account) return error('Invalid token');\n      return ok();\n    }\n    function resetPassword() {\n      const {\n        token,\n        password\n      } = body;\n      const account = accounts.find(x => !!x.resetToken && x.resetToken === token && new Date() < new Date(x.resetTokenExpires));\n      if (!account) return error('Invalid token');\n      // update password and remove reset token\n      account.password = password;\n      account.isVerified = true;\n      delete account.resetToken;\n      delete account.resetTokenExpires;\n      localStorage.setItem(accountsKey, JSON.stringify(accounts));\n      return ok();\n    }\n    function getAccounts() {\n      if (!isAuthenticated()) return unauthorized();\n      return ok(accounts.map(x => basicDetails(x)));\n    }\n    function getAccountById() {\n      if (!isAuthenticated()) return unauthorized();\n      let account = accounts.find(x => x.id === idFromUrl());\n      // user accounts can get own profile and admin accounts can get all profiles\n      if (account.id !== currentAccount().id && !isAuthorized(Role.Admin)) {\n        return unauthorized();\n      }\n      return ok(basicDetails(account));\n    }\n    function createAccount() {\n      if (!isAuthorized(Role.Admin)) return unauthorized();\n      const account = body;\n      if (accounts.find(x => x.email === account.email)) {\n        return error(`Email ${account.email} is already registered`);\n      }\n      // assign account id and a few other properties then save\n      account.id = newAccountId();\n      account.dateCreated = new Date().toISOString();\n      account.isVerified = true;\n      account.refreshTokens = [];\n      delete account.confirmPassword;\n      accounts.push(account);\n      localStorage.setItem(accountsKey, JSON.stringify(accounts));\n      return ok();\n    }\n    function updateAccount() {\n      if (!isAuthenticated()) return unauthorized();\n      let params = body;\n      let account = accounts.find(x => x.id === idFromUrl());\n      // user accounts can update own profile and admin accounts can update all profiles\n      if (account.id !== currentAccount().id && !isAuthorized(Role.Admin)) {\n        return unauthorized();\n      }\n      // only update password if included\n      if (!params.password) {\n        delete params.password;\n      }\n      // don't save confirm password\n      delete params.confirmPassword;\n      // update and save account\n      Object.assign(account, params);\n      localStorage.setItem(accountsKey, JSON.stringify(accounts));\n      return ok(basicDetails(account));\n    }\n    function deleteAccount() {\n      if (!isAuthenticated()) return unauthorized();\n      let account = accounts.find(x => x.id === idFromUrl());\n      // user accounts can delete own account and admin accounts can delete any account\n      if (account.id !== currentAccount().id && !isAuthorized(Role.Admin)) {\n        return unauthorized();\n      }\n      // delete account then save\n      accounts = accounts.filter(x => x.id !== idFromUrl());\n      localStorage.setItem(accountsKey, JSON.stringify(accounts));\n      return ok();\n    }\n    // helper functions\n    function ok(body) {\n      return of(new HttpResponse({\n        status: 200,\n        body\n      })).pipe(delay(500)); // delay observable to simulate server api call\n    }\n\n    function error(message) {\n      return throwError(() => ({\n        error: {\n          message\n        }\n      })).pipe(materialize(), delay(500), dematerialize()); // call materialize and dematerialize to ensure delay even if an error is thrown (https://github.com/Reactive-Extensions/RxJS/issues/648);\n    }\n\n    function unauthorized() {\n      return throwError(() => ({\n        status: 401,\n        error: {\n          message: 'Unauthorized'\n        }\n      })).pipe(materialize(), delay(500), dematerialize());\n    }\n    function basicDetails(account) {\n      const {\n        id,\n        title,\n        firstName,\n        lastName,\n        email,\n        role,\n        dateCreated,\n        isVerified\n      } = account;\n      return {\n        id,\n        title,\n        firstName,\n        lastName,\n        email,\n        role,\n        dateCreated,\n        isVerified\n      };\n    }\n    function isAuthenticated() {\n      return !!currentAccount();\n    }\n    function isAuthorized(role) {\n      const account = currentAccount();\n      if (!account) return false;\n      return account.role === role;\n    }\n    function idFromUrl() {\n      const urlParts = url.split('/');\n      return parseInt(urlParts[urlParts.length - 1]);\n    }\n    function newAccountId() {\n      return accounts.length ? Math.max(...accounts.map(x => x.id)) + 1 : 1;\n    }\n    function currentAccount() {\n      // check if jwt token is in auth header\n      const authHeader = headers.get('Authorization');\n      if (!authHeader?.startsWith('Bearer fake-jwt-token')) return;\n      // check if token is expired\n      const jwtToken = JSON.parse(atob(authHeader.split('.')[1]));\n      const tokenExpired = Date.now() > jwtToken.exp * 1000;\n      if (tokenExpired) return;\n      const account = accounts.find(x => x.id === jwtToken.id);\n      return account;\n    }\n    function generateJwtToken(account) {\n      // create token that expires in 15 minutes\n      const tokenPayload = {\n        exp: Math.round(new Date(Date.now() + 15 * 60 * 1000).getTime() / 1000),\n        id: account.id\n      };\n      return `fake-jwt-token.${btoa(JSON.stringify(tokenPayload))}`;\n    }\n    function generateRefreshToken() {\n      const token = new Date().getTime().toString();\n      // add token cookie that expires in 7 days\n      const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toUTCString();\n      document.cookie = `fakeRefreshToken=${token}; expires=${expires}; path=/`;\n      return token;\n    }\n    function getRefreshToken() {\n      // get refresh token from cookie\n      return (document.cookie.split(';').find(x => x.includes('fakeRefreshToken')) || '=').split('=')[1];\n    }\n  }\n}\nFakeBackendInterceptor.ɵfac = function FakeBackendInterceptor_Factory(t) {\n  return new (t || FakeBackendInterceptor)(i0.ɵɵinject(i1.AlertService));\n};\nFakeBackendInterceptor.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: FakeBackendInterceptor,\n  factory: FakeBackendInterceptor.ɵfac\n});\nexport let fakeBackendProvider = {\n  // use fake backend in place of Http service for backend-less development\n  provide: HTTP_INTERCEPTORS,\n  useClass: FakeBackendInterceptor,\n  multi: true\n};","map":{"version":3,"mappings":"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","names":["HttpResponse","HTTP_INTERCEPTORS","of","throwError","delay","materialize","dematerialize","Role","accountsKey","accounts","JSON","parse","localStorage","getItem","FakeBackendInterceptor","constructor","alertService","intercept","request","next","url","method","headers","body","handleRoute","endsWith","authenticate","refreshToken","revokeToken","register","verifyEmail","forgotPassword","validateResetToken","resetPassword","getAccounts","match","getAccountById","createAccount","updateAccount","deleteAccount","handle","email","password","account","find","x","isVerified","error","refreshTokens","push","generateRefreshToken","setItem","stringify","ok","basicDetails","jwtToken","generateJwtToken","getRefreshToken","unauthorized","includes","filter","isAuthenticated","setTimeout","info","location","origin","autoClose","id","newAccountId","role","Admin","User","dateCreated","Date","toISOString","verificationToken","getTime","toString","confirmPassword","verifyUrl","token","resetToken","resetTokenExpires","now","resetUrl","map","idFromUrl","currentAccount","isAuthorized","params","Object","assign","status","pipe","message","title","firstName","lastName","urlParts","split","parseInt","length","Math","max","authHeader","get","startsWith","atob","tokenExpired","exp","tokenPayload","round","btoa","expires","toUTCString","document","cookie","factory","fakeBackendProvider","provide","useClass","multi"],"sourceRoot":"","sources":["D:\\boilerplates\\angularFrontendBoilerplate\\src\\app\\_helpers\\fake-backend.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { HttpRequest, HttpResponse, HttpHandler, HttpEvent, HttpInterceptor, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { Observable, of, throwError } from 'rxjs';\nimport { delay, materialize, dematerialize } from 'rxjs/operators';\n\nimport { AlertService } from '@app/_services';\nimport { Role } from '@app/_models';\n\n\n\n// array in local storage for accounts\nconst accountsKey = 'angular-15-signup-verification-boilerplate-accounts';\nlet accounts: any[] = JSON.parse(localStorage.getItem(accountsKey)!) || [];\n\n\n@Injectable()\nexport class FakeBackendInterceptor implements HttpInterceptor {\n    constructor(private alertService: AlertService) { }\n\n    intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n        const { url, method, headers, body } = request;\n        const alertService = this.alertService;\n\n        return handleRoute();\n\n        function handleRoute() {\n            switch (true) {\n                case url.endsWith('/accounts/authenticate') && method === 'POST':\n                    return authenticate();\n                case url.endsWith('/accounts/refresh-token') && method === 'POST':\n                    return refreshToken();\n                case url.endsWith('/accounts/revoke-token') && method === 'POST':\n                    return revokeToken();\n                case url.endsWith('/accounts/register') && method === 'POST':\n                    return register();\n                case url.endsWith('/accounts/verify-email') && method === 'POST':\n                    return verifyEmail();\n                case url.endsWith('/accounts/forgot-password') && method === 'POST':\n                    return forgotPassword();\n                case url.endsWith('/accounts/validate-reset-token') && method === 'POST':\n                    return validateResetToken();\n                case url.endsWith('/accounts/reset-password') && method === 'POST':\n                    return resetPassword();\n                case url.endsWith('/accounts') && method === 'GET':\n                    return getAccounts();\n                case url.match(/\\/accounts\\/\\d+$/) && method === 'GET':\n                    return getAccountById();\n                case url.endsWith('/accounts') && method === 'POST':\n                    return createAccount();\n                case url.match(/\\/accounts\\/\\d+$/) && method === 'PUT':\n                    return updateAccount();\n                case url.match(/\\/accounts\\/\\d+$/) && method === 'DELETE':\n                    return deleteAccount();\n                default:\n                    // pass through any requests not handled above\n                    return next.handle(request);\n            }    \n        }\n\n        // route functions\n\n        function authenticate() {\n            const { email, password } = body;\n            const account = accounts.find(x => x.email === email && x.password === password && x.isVerified);\n            \n            if (!account) return error('Email or password is incorrect');\n\n            // add refresh token to account\n            account.refreshTokens.push(generateRefreshToken());\n            localStorage.setItem(accountsKey, JSON.stringify(accounts));\n\n            return ok({\n                ...basicDetails(account),\n                jwtToken: generateJwtToken(account)\n            });\n        }\n\n        function refreshToken() {\n            const refreshToken = getRefreshToken();\n            \n            if (!refreshToken) return unauthorized();\n\n            const account = accounts.find(x => x.refreshTokens.includes(refreshToken));\n            \n            if (!account) return unauthorized();\n\n            // replace old refresh token with a new one and save\n            account.refreshTokens = account.refreshTokens.filter((x: any) => x !== refreshToken);\n            account.refreshTokens.push(generateRefreshToken());\n            localStorage.setItem(accountsKey, JSON.stringify(accounts));\n\n            return ok({\n                ...basicDetails(account),\n                jwtToken: generateJwtToken(account)\n            });\n        }\n\n        function revokeToken() {\n            if (!isAuthenticated()) return unauthorized();\n            \n            const refreshToken = getRefreshToken();\n            const account = accounts.find(x => x.refreshTokens.includes(refreshToken));\n            \n            // revoke token and save\n            account.refreshTokens = account.refreshTokens.filter((x: any) => x !== refreshToken);\n            localStorage.setItem(accountsKey, JSON.stringify(accounts));\n\n            return ok();\n        }\n\n        function register() {\n            const account = body;\n\n            if (accounts.find(x => x.email === account.email)) {\n                // display email already registered \"email\" in alert\n                setTimeout(() => {\n                    alertService.info(`\n                        <h4>Email Already Registered</h4>\n                        <p>Your email ${account.email} is already registered.</p>\n                        <p>If you don't know your password please visit the <a href=\"${location.origin}/account/forgot-password\">forgot password</a> page.</p>\n                        <div><strong>NOTE:</strong> The fake backend displayed this \"email\" so you can test without an api. A real backend would send a real email.</div>\n                    `, { autoClose: false });\n                }, 1000);\n\n                // always return ok() response to prevent email enumeration\n                return ok();\n            }\n\n            // assign account id and a few other properties then save\n            account.id = newAccountId();\n            if (account.id === 1) {\n                // first registered account is an admin\n                account.role = Role.Admin;\n            } else {\n                account.role = Role.User;\n            }\n            account.dateCreated = new Date().toISOString();\n            account.verificationToken = new Date().getTime().toString();\n            account.isVerified = false;\n            account.refreshTokens = [];\n            delete account.confirmPassword;\n            accounts.push(account);\n            localStorage.setItem(accountsKey, JSON.stringify(accounts));\n\n            // display verification email in alert\n            setTimeout(() => {\n                const verifyUrl = `${location.origin}/account/verify-email?token=${account.verificationToken}`;\n                alertService.info(`\n                    <h4>Verification Email</h4>\n                    <p>Thanks for registering!</p>\n                    <p>Please click the below link to verify your email address:</p>\n                    <p><a href=\"${verifyUrl}\">${verifyUrl}</a></p>\n                    <div><strong>NOTE:</strong> The fake backend displayed this \"email\" so you can test without an api. A real backend would send a real email.</div>\n                `, { autoClose: false });\n            }, 1000);\n\n            return ok();\n        }\n        \n        function verifyEmail() {\n            const { token } = body;\n            const account = accounts.find(x => !!x.verificationToken && x.verificationToken === token);\n            \n            if (!account) return error('Verification failed');\n            \n            // set is verified flag to true if token is valid\n            account.isVerified = true;\n            localStorage.setItem(accountsKey, JSON.stringify(accounts));\n\n            return ok();\n        }\n\n        function forgotPassword() {\n            const { email } = body;\n            const account = accounts.find(x => x.email === email);\n            \n            // always return ok() response to prevent email enumeration\n            if (!account) return ok();\n            \n            // create reset token that expires after 24 hours\n            account.resetToken = new Date().getTime().toString();\n            account.resetTokenExpires = new Date(Date.now() + 24*60*60*1000).toISOString();\n            localStorage.setItem(accountsKey, JSON.stringify(accounts));\n\n            // display password reset email in alert\n            setTimeout(() => {\n                const resetUrl = `${location.origin}/account/reset-password?token=${account.resetToken}`;\n                alertService.info(`\n                    <h4>Reset Password Email</h4>\n                    <p>Please click the below link to reset your password, the link will be valid for 1 day:</p>\n                    <p><a href=\"${resetUrl}\">${resetUrl}</a></p>\n                    <div><strong>NOTE:</strong> The fake backend displayed this \"email\" so you can test without an api. A real backend would send a real email.</div>\n                `, { autoClose: false });\n            }, 1000);\n\n            return ok();\n        }\n        \n        function validateResetToken() {\n            const { token } = body;\n            const account = accounts.find(x =>\n                !!x.resetToken && x.resetToken === token &&\n                new Date() < new Date(x.resetTokenExpires)\n            );\n            \n            if (!account) return error('Invalid token');\n            \n            return ok();\n        }\n\n        function resetPassword() {\n            const { token, password } = body;\n            const account = accounts.find(x =>\n                !!x.resetToken && x.resetToken === token &&\n                new Date() < new Date(x.resetTokenExpires)\n            );\n            \n            if (!account) return error('Invalid token');\n            \n            // update password and remove reset token\n            account.password = password;\n            account.isVerified = true;\n            delete account.resetToken;\n            delete account.resetTokenExpires;\n            localStorage.setItem(accountsKey, JSON.stringify(accounts));\n\n            return ok();\n        }\n\n        function getAccounts() {\n            if (!isAuthenticated()) return unauthorized();\n            return ok(accounts.map(x => basicDetails(x)));\n        }\n\n        function getAccountById() {\n            if (!isAuthenticated()) return unauthorized();\n\n            let account = accounts.find(x => x.id === idFromUrl());\n\n            // user accounts can get own profile and admin accounts can get all profiles\n            if (account.id !== currentAccount().id && !isAuthorized(Role.Admin)) {\n                return unauthorized();\n            }\n\n            return ok(basicDetails(account));\n        }\n\n        function createAccount() {\n            if (!isAuthorized(Role.Admin)) return unauthorized();\n\n            const account = body;\n            if (accounts.find(x => x.email === account.email)) {\n                return error(`Email ${account.email} is already registered`);\n            }\n\n            // assign account id and a few other properties then save\n            account.id = newAccountId();\n            account.dateCreated = new Date().toISOString();\n            account.isVerified = true;\n            account.refreshTokens = [];\n            delete account.confirmPassword;\n            accounts.push(account);\n            localStorage.setItem(accountsKey, JSON.stringify(accounts));\n\n            return ok();\n        }\n\n        function updateAccount() {\n            if (!isAuthenticated()) return unauthorized();\n\n            let params = body;\n            let account = accounts.find(x => x.id === idFromUrl());\n\n            // user accounts can update own profile and admin accounts can update all profiles\n            if (account.id !== currentAccount().id && !isAuthorized(Role.Admin)) {\n                return unauthorized();\n            }\n\n            // only update password if included\n            if (!params.password) {\n                delete params.password;\n            }\n            // don't save confirm password\n            delete params.confirmPassword;\n\n            // update and save account\n            Object.assign(account, params);\n            localStorage.setItem(accountsKey, JSON.stringify(accounts));\n\n            return ok(basicDetails(account));\n        }\n\n        function deleteAccount() {\n            if (!isAuthenticated()) return unauthorized();\n\n            let account = accounts.find(x => x.id === idFromUrl());\n\n            // user accounts can delete own account and admin accounts can delete any account\n            if (account.id !== currentAccount().id && !isAuthorized(Role.Admin)) {\n                return unauthorized();\n            }\n\n            // delete account then save\n            accounts = accounts.filter(x => x.id !== idFromUrl());\n            localStorage.setItem(accountsKey, JSON.stringify(accounts));\n            return ok();\n        }\n        \n        // helper functions\n\n        function ok(body?: any) {\n            return of(new HttpResponse({ status: 200, body }))\n                .pipe(delay(500)); // delay observable to simulate server api call\n        }\n\n        function error(message: string) {\n            return throwError(() => ({ error: { message } }))\n                .pipe(materialize(), delay(500), dematerialize()); // call materialize and dematerialize to ensure delay even if an error is thrown (https://github.com/Reactive-Extensions/RxJS/issues/648);\n        }\n\n        function unauthorized() {\n            return throwError(() => ({ status: 401, error: { message: 'Unauthorized' } }))\n                .pipe(materialize(), delay(500), dematerialize());\n        }\n\n        function basicDetails(account: any) {\n            const { id, title, firstName, lastName, email, role, dateCreated, isVerified } = account;\n            return { id, title, firstName, lastName, email, role, dateCreated, isVerified };\n        }\n\n        function isAuthenticated() {\n            return !!currentAccount();\n        }\n\n        function isAuthorized(role: any) {\n            const account = currentAccount();\n            if (!account) return false;\n            return account.role === role;\n        }\n\n        function idFromUrl() {\n            const urlParts = url.split('/');\n            return parseInt(urlParts[urlParts.length - 1]);\n        }\n\n        function newAccountId() {\n            return accounts.length ? Math.max(...accounts.map(x => x.id)) + 1 : 1;\n        }\n\n        function currentAccount() {\n            // check if jwt token is in auth header\n            const authHeader = headers.get('Authorization');\n            if (!authHeader?.startsWith('Bearer fake-jwt-token')) return;\n\n            // check if token is expired\n            const jwtToken = JSON.parse(atob(authHeader.split('.')[1]));\n            const tokenExpired = Date.now() > (jwtToken.exp * 1000);\n            if (tokenExpired) return;\n\n            const account = accounts.find(x => x.id === jwtToken.id);\n            return account;\n        }\n\n        function generateJwtToken(account: any) {\n            // create token that expires in 15 minutes\n            const tokenPayload = { \n                exp: Math.round(new Date(Date.now() + 15*60*1000).getTime() / 1000),\n                id: account.id\n            }\n            return `fake-jwt-token.${btoa(JSON.stringify(tokenPayload))}`;\n        }\n\n        function generateRefreshToken() {\n            const token = new Date().getTime().toString();\n\n            // add token cookie that expires in 7 days\n            const expires = new Date(Date.now() + 7*24*60*60*1000).toUTCString();\n            document.cookie = `fakeRefreshToken=${token}; expires=${expires}; path=/`;\n\n            return token;\n        }\n\n        function getRefreshToken() {\n            // get refresh token from cookie\n            return (document.cookie.split(';').find(x => x.includes('fakeRefreshToken')) || '=').split('=')[1];\n        }\n    }\n}\n\nexport let fakeBackendProvider = {\n    // use fake backend in place of Http service for backend-less development\n    provide: HTTP_INTERCEPTORS,\n    useClass: FakeBackendInterceptor,\n    multi: true   \n};\n\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}